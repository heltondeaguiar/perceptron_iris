# -*- coding: utf-8 -*-
"""perceptron_iris_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NpYRd672guEb9mSePslgtbDaP2f6JXrE

    **Helton Aguiar - 11811BSI242**
    **Gabriel Oliveira - 11821BSI20**
    
"""

import random
import pandas as pd
import numpy as np
from sklearn.metrics import confusion_matrix

# Função para carregar os dados da base Iris a partir do arquivo local
def carregar_dados_iris(classe1, classe2, classe3):
    dados_iris = pd.read_csv("iris.data", header=None, names=["comprimento_sepala", "largura_sepala", "comprimento_petala", "largura_petala", "classe"])
    dados_iris = dados_iris[(dados_iris["classe"] == classe1) | (dados_iris["classe"] == classe2) | (dados_iris["classe"] == classe3)]
    mapeamento_classes = {classe1: 1, classe2: -1, classe3: -1}
    dados_iris["classe"] = dados_iris["classe"].map(mapeamento_classes)
    return dados_iris

# Função para treinar o perceptron
def treinar_perceptron(dados, taxa_aprendizado, iteracoes):
    num_caracteristicas = dados.shape[1] - 1
    pesos = [random.uniform(-1, 1) for _ in range(num_caracteristicas)]
    erros = []

    for i in range(iteracoes):
        erro_total = 0
        for j in range(len(dados)):
            x = dados.iloc[j, :-1].values
            y = dados.iloc[j, -1]

            previsao = np.dot(pesos, x)
            if y * previsao <= 0:
                pesos += taxa_aprendizado * y * x
                erro_total += 1

        erros.append(erro_total)
       # print(f"Iteração {i + 1}: Número de Erros = {erro_total}")

    return pesos, erros

# Função para fazer previsões com o perceptron treinado
def prever_perceptron(pesos, x):
    previsao = np.dot(pesos, x)
    return 1 if previsao > 0 else -1

# Função para avaliar a precisão do perceptron
def avaliar_perceptron(pesos, dados):
    previsoes = [prever_perceptron(pesos, dados.iloc[i, :-1].values) for i in range(len(dados))]
    verdadeiros = dados["classe"].values
    matriz_confusao = confusion_matrix(verdadeiros, previsoes)

    if matriz_confusao.shape == (1, 1):
        precisao = 1.0  # Lidando com o caso em que há apenas um valor na matriz de confusão
    else:
        precisao = matriz_confusao[0, 0] / (matriz_confusao[0, 0] + matriz_confusao[0, 1])

    print("Matriz de Confusão:")
    print(matriz_confusao)
    return precisao

# Carregando os dados da base Iris
dados_iris = carregar_dados_iris("Iris-setosa", "Iris-versicolor", "Iris-virginica")

# Dividindo os dados em treinamento e teste (70% treinamento, 30% teste)
percentual_treinamento = 0.7
tamanho_treinamento = int(percentual_treinamento * len(dados_iris))
dados_treinamento = dados_iris[:tamanho_treinamento]
dados_teste = dados_iris[tamanho_treinamento:]

# Parâmetros de treinamento
taxa_aprendizado = 0.1
iteracoes = 100

# Treinando o perceptron
pesos_treinados, erros = treinar_perceptron(dados_treinamento, taxa_aprendizado, iteracoes)
print("Pesos Treinados:")
print(pesos_treinados)

# Avaliando a precisão do perceptron nos dados de teste
precisao = avaliar_perceptron(pesos_treinados, dados_teste)
print(f"Precisão nos dados de teste: {precisao}")

# Tabela de resultados
resultados = pd.DataFrame({
    "Iteração": range(1, iteracoes + 1),
    "Erros": erros
})

#print("Tabela de Resultados:")
#print(resultados)

# Plotando a curva de erro durante o treinamento
import matplotlib.pyplot as plt

plt.plot(range(1, iteracoes + 1), erros)
plt.xlabel("Iterações")
plt.ylabel("Erros")
plt.title("Erro de Treinamento ao Longo das Iterações")
plt.show()
