# -*- coding: utf-8 -*-
"""perceptron_iris.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Gl8Oh5dpP9c7xH-A6wHwl9RNIvB5qMK6

    **Helton Aguiar - 11811BSI242**
    **Gabriel Oliveira - 11821BSI20**

**Segunda Atividade Prática**

**1 Implementação de um perceptron para classificar dados da base Iris**

>O objetivo deste trabalho é explorar a implementação e os diferentes parâmetros da rede neural perceptron. Para isso, será utilizada a base de dados Iris, disponível [aqui](https://archive.ics.uci.edu/dataset/53/iris). Trata-se de um conjunto de dados de uma espécie de planta florida. Essa base contém as características de três variedades de iris: Setosa, Versicolour e Virginica. Para cada variedade, são apresentadas quatro característica: comprimento da sépala (sepal length), largura da sépala (sepal width), comprimento da pétala (petal length) e largura da pétala (petal width). A partir dessas características, é possível classificar as plantas em uma das três variedades.

>Você deve implementar um perceptron de uma camada (single layer perceptron), como visto em aula. As classes da iris podem ser consideradas linearmente separáveis duas a duas; logo, você deve selecionar duas espécies de iris para fazer sua classificação. Treine sua rede neural iniciando com pesos aleatórios e com uma parte do conjunto de dados. Em seguida, usando os pesos encontrados pela rede, classifique o restante do conjunto de dados.

1.1 Tarefas

>*   Você deve escolher duas classes de iris para fazer a classificação.
*   Você deve treinar sua rede com diferentes porcentagens da base original. Por exemplo, selecione 30% do conjunto e treine sua rede; em seguida, tente “prever” em qual categoria os 70% restante do conjuntos será classificado. Faça testes com diferentes conjuntos de treino: 10%, 30% e 50%.
*   Avalie diferentes valores da taxa de aprendizado (η) e diferentes valores para o total de iterações (epoch).
*   Tente incluir a terceira classe de iris nos seus experimentos. Reporte o que acontecerá.
"""

import random
import pandas as pd
import numpy as np
from sklearn.metrics import confusion_matrix

# pd.set_option('display.max_rows', None)

# Função para carregar os dados da base Iris a partir do arquivo local
def carregar_dados_iris(classe1, classe2):
    dados_iris = pd.read_csv("iris.data", header=None, names=["comprimento_sepala", "largura_sepala", "comprimento_petala", "largura_petala", "classe"])
    dados_iris = dados_iris[(dados_iris["classe"] == classe1) | (dados_iris["classe"] == classe2)]
    dados_iris["classe"] = np.where(dados_iris["classe"] == classe1, 1, -1)
    return dados_iris

# Função para treinar o perceptron
def treinar_perceptron(dados, taxa_aprendizado, iteracoes):
    num_caracteristicas = dados.shape[1] - 1
    pesos = [random.uniform(-1, 1) for _ in range(num_caracteristicas)]
    erros = []

    for i in range(iteracoes):
        erro_total = 0
        for j in range(len(dados)):
            x = dados.iloc[j, :-1].values
            y = dados.iloc[j, -1]

            previsao = np.dot(pesos, x)
            if y * previsao <= 0:
                pesos += taxa_aprendizado * y * x
                erro_total += 1

        erros.append(erro_total)
        #print(f"Iteração {i + 1}: Número de Erros = {erro_total}")

    return pesos, erros

# Função para fazer previsões com o perceptron treinado
def prever_perceptron(pesos, x):
    previsao = np.dot(pesos, x)
    return 1 if previsao > 0 else -1

# Função para avaliar a precisão do perceptron
def avaliar_perceptron(pesos, dados):
    previsoes = [prever_perceptron(pesos, dados.iloc[i, :-1].values) for i in range(len(dados))]
    verdadeiros = dados["classe"].values
    matriz_confusao = confusion_matrix(verdadeiros, previsoes)

    if matriz_confusao.shape == (1, 1):
        precisao = 1.0  # Lidando com o caso em que há apenas um valor na matriz de confusão
    else:
        precisao = matriz_confusao[0, 0] / (matriz_confusao[0, 0] + matriz_confusao[0, 1])

    print("Matriz de Confusão:")
    print(matriz_confusao)
    return precisao

# Carregando os dados da base Iris
dados_iris = carregar_dados_iris("Iris-setosa", "Iris-versicolor")

# Dividindo os dados em treinamento e teste (70% treinamento, 30% teste)
percentual_treinamento = 0.7
tamanho_treinamento = int(percentual_treinamento * len(dados_iris))
dados_treinamento = dados_iris[:tamanho_treinamento]
dados_teste = dados_iris[tamanho_treinamento:]

# Parâmetros de treinamento
taxa_aprendizado = 0.1
iteracoes = 100

# Treinando o perceptron
pesos_treinados, erros = treinar_perceptron(dados_treinamento, taxa_aprendizado, iteracoes)
print("Pesos Treinados:")
print(pesos_treinados)

# Avaliando a precisão do perceptron nos dados de teste
precisao = avaliar_perceptron(pesos_treinados, dados_teste)
print(f"Precisão nos dados de teste: {precisao}")

# Tabela de resultados
resultados = pd.DataFrame({
    "Iteração": range(1, iteracoes + 1),
    "Erros": erros
})

#print("Tabela de Resultados:")
#print(resultados)

# Plotando a curva de erro durante o treinamento

import matplotlib.pyplot as plt

plt.plot(range(1, iteracoes + 1), erros)
plt.xlabel("Iterações")
plt.ylabel("Erros")
plt.title("Erro de Treinamento ao Longo das Iterações")
plt.show()
